"""
Módulo de Informe de Órdenes de Pago - Migración completa desde pagos.py
- Gestión completa de pagos y abonos
- Filtros avanzados y búsqueda parcial
- Actualización masiva de fechas de pago
- Exportación a Excel optimizada
- Sistema de permisos integrado
- Compatible con Supabase

LÓGICA DE PAGOS - DOS MÉTODOS:

MÉTODO A - PAGO DIRECTO:
- Usuario asigna fecha de pago directamente
- Representa pago completo (saldo = 0)
- No requiere abonos previos
- Independiente del sistema de abonos

MÉTODO B - PAGO POR ABONOS:
- Usuario registra abonos parciales
- Sistema suma abonos hasta completar total
- Cuando abonos = total → auto-asigna fecha de pago
- Si se elimina abono y saldo > 0 → se elimina fecha de pago automática

REGLAS DE CONVIVENCIA:
1. Pago directo (fecha) siempre tiene precedencia
2. Sistema de abonos solo gestiona fechas automáticas
3. No eliminar fechas de pago directo por cambios en abonos
4. Permitir ambos métodos sin interferencia
"""

from flask import (
    Blueprint, render_template, request,
    flash, redirect, url_for, current_app,
    send_file, jsonify
)
from datetime import date, datetime, timedelta
from flask_login import login_required
from openpyxl import Workbook
from io import BytesIO
from app.modules.usuarios import require_modulo, get_modulos_usuario
from app.utils.static_data import get_cached_proveedores, get_cached_proyectos_with_id
from utils.logger import registrar_log_actividad

bp_informe_op = Blueprint(
    "informe_op", __name__,
    template_folder="../templates"
)

def get_informe_pagos(filtros=None):
    """
    Función optimizada para obtener datos del informe de pagos
    Migrada desde pagos.py con optimizaciones
    """
    supabase = current_app.config["SUPABASE"]
    
    # Obtener todos los registros sin paginación (optimizado por lotes)
    page_size = 1000  
    offset = 0
    all_rows = []
    
    try:
        while True:
            batch = supabase \
                .table("orden_de_pago") \
                .select("orden_numero, fecha, proveedor, proveedor_nombre, detalle_compra, factura, costo_final_con_iva, proyecto, orden_compra, condicion_pago, vencimiento, fecha_factura, ingreso_id") \
                .order("orden_numero") \
                .range(offset, offset + page_size - 1) \
                .execute() \
                .data or []

            all_rows.extend(batch)
            if len(batch) < page_size:
                break
            offset += page_size
    except Exception as e:
        print(f"[ERROR] Consulta orden_de_pago: {e}")
        return []

    # Obtener nombres de proyectos ANTES de aplicar filtros
    proyecto_map = {}
    try:
        projs = get_cached_proyectos_with_id()
        proyecto_map = {pr["id"]: pr["proyecto"] for pr in projs}
        for r in all_rows:
            proj_id = r.get("proyecto")
            r["proyecto_nombre"] = proyecto_map.get(proj_id, proj_id)
    except Exception as e:
        print(f"[ERROR] Consulta proyectos: {e}")

    # Aplicar filtros avanzados DESPUÉS de tener nombres de proyectos
    if filtros:
        # Filtro de búsqueda parcial (proveedor, detalle, factura, proyecto, número de orden)
        search = filtros.get("proveedor", "").strip().lower()
        if search:
            all_rows = [r for r in all_rows if search in str(r.get("proveedor_nombre", "")).lower()
                        or search in str(r.get("detalle_compra", "")).lower()
                        or search in str(r.get("factura", "")).lower()
                        or search in str(r.get("proyecto_nombre", "")).lower()
                        or search in str(r.get("orden_numero", "")).lower()]

        # Filtro de proyecto exacto por NOMBRE
        proyecto = filtros.get("proyecto", "").strip()
        if proyecto:
            all_rows = [r for r in all_rows if str(r.get("proyecto_nombre", "")) == proyecto]
            print(f"[INFO] Filtro proyecto '{proyecto}' aplicado: {len(all_rows)} registros")

        # Filtros de fecha
        fecha_desde = filtros.get("fecha_desde", "").strip()
        if fecha_desde:
            all_rows = [r for r in all_rows if r.get("fecha", "") >= fecha_desde]
            
        fecha_hasta = filtros.get("fecha_hasta", "").strip()
        if fecha_hasta:
            all_rows = [r for r in all_rows if r.get("fecha", "") <= fecha_hasta]

    # Agrupar por orden_numero único y sumar montos
    pagos = {}
    for r in all_rows:
        try:
            num = int(r["orden_numero"])
        except (ValueError, TypeError):
            continue  # Omitir si no se puede convertir
            
        if num not in pagos:
            pagos[num] = {
                "orden_numero": num,
                "fecha": r["fecha"],
                "proveedor": r.get("proveedor"),  # ID del proveedor
                "proveedor_nombre": r["proveedor_nombre"],
                "detalle_compra": r["detalle_compra"],
                "factura": r["factura"],
                "total_pago": 0.0,
                "proyecto_id": r["proyecto"],
                "proyecto": r.get("proyecto_nombre", r["proyecto"]),  # Usar nombre si está disponible
                "orden_compra": r["orden_compra"],
                "condicion_pago": r["condicion_pago"],
                "vencimiento": r["vencimiento"],
                "fecha_factura": r["fecha_factura"],
                "ingreso_id": r.get("ingreso_id"),
                "fecha_pago": None,
                "total_abonado": 0.0,
                "saldo_pendiente": 0.0,
                "item": "",
                "rut_proveedor": "-",
                "cuenta": "",
                "fac_pago": "-"
            }
        pagos[num]["total_pago"] += float(r.get("costo_final_con_iva") or 0)

    # Ordenar de mayor a menor por orden_numero
    pagos_ordenados = [pagos[k] for k in sorted(pagos.keys(), reverse=True)]

    # Obtener fechas de pago en batch (con límite para evitar errores de Supabase)
    ordenes_numeros = [p["orden_numero"] for p in pagos_ordenados]
    fecha_map = {}
    if ordenes_numeros:
        try:
            batch_size = 100  # Reducir tamaño de batch para evitar límites de Supabase
            for i in range(0, len(ordenes_numeros), batch_size):
                batch_ordenes = ordenes_numeros[i:i+batch_size]
                fechas_batch = supabase.table("fechas_de_pagos_op").select("orden_numero, fecha_pago").in_("orden_numero", batch_ordenes).execute().data or []
                for row in fechas_batch:
                    fecha_map[row["orden_numero"]] = row["fecha_pago"]
            
            for p in pagos_ordenados:
                p["fecha_pago"] = fecha_map.get(p["orden_numero"])
                
            print(f"[INFO] Cargadas {len(fecha_map)} fechas de pago de {len(ordenes_numeros)} órdenes")
        except Exception as e:
            print(f"[ERROR] Consulta fechas de pago: {e}")

    # Obtener abonos en batch (con límite para evitar errores de Supabase)
    abonos_map = {}
    if ordenes_numeros:
        try:
            batch_size = 100  # Reducir tamaño de batch
            for i in range(0, len(ordenes_numeros), batch_size):
                batch_ordenes = ordenes_numeros[i:i+batch_size]
                abonos_batch = supabase.table("abonos_op").select("orden_numero, monto_abono").in_("orden_numero", batch_ordenes).execute().data or []
                
                for ab in abonos_batch:
                    num = ab.get("orden_numero")
                    if num is not None:
                        try:
                            monto = float(ab.get("monto_abono") or 0)
                            abonos_map[num] = abonos_map.get(num, 0) + monto
                        except (ValueError, TypeError):
                            continue
            
            for p in pagos_ordenados:
                num = p["orden_numero"]
                total_abonado = abonos_map.get(num, 0)
                p["total_abonado"] = total_abonado
                # Si existe fecha_pago → saldo = 0, sino saldo = total - abonos
                p["saldo_pendiente"] = 0 if p.get("fecha_pago") else max(0, p["total_pago"] - total_abonado)
                
            print(f"[INFO] Cargados abonos para {len(abonos_map)} órdenes")
        except Exception as e:
            print(f"[ERROR] Consulta abonos: {e}")

    # Obtener items por orden_compra
    ordenes_compra_unicas = set(p["orden_compra"] for p in pagos_ordenados if p.get("orden_compra"))
    if ordenes_compra_unicas:
        items_por_orden = {}
        try:
            batch_size = 100
            ordenes_list = list(ordenes_compra_unicas)
            for i in range(0, len(ordenes_list), batch_size):
                batch_ordenes = ordenes_list[i:i+batch_size]
                batch_items = supabase.table("orden_de_compra").select("orden_compra,item").in_("orden_compra", batch_ordenes).execute().data or []
                for oc in batch_ordenes:
                    items = set(row["item"] for row in batch_items if row["orden_compra"] == oc and row.get("item"))
                    items_por_orden[oc] = ", ".join(sorted(items)) if items else ""
            
            for p in pagos_ordenados:
                oc = p.get("orden_compra")
                p["item"] = items_por_orden.get(oc, "")
        except Exception as e:
            print(f"[ERROR] Consulta items: {e}")

    # Obtener datos de proveedores (RUT y cuenta corriente)
    try:
        provs = get_cached_proveedores()
        cuenta_map = {p["nombre"]: p["cuenta"] for p in provs}
        rut_map = {}
        for p in provs:
            if p.get("id") is not None and p.get("rut"):
                rut_map[p["id"]] = p["rut"]
                try:
                    rut_map[int(p["id"])] = p["rut"]
                    rut_map[str(p["id"])] = p["rut"]
                except (ValueError, TypeError):
                    pass
        
        for p in pagos_ordenados:
            p["cuenta"] = cuenta_map.get(p["proveedor_nombre"], "")
            p["rut_proveedor"] = rut_map.get(p.get("proveedor"), "-")
    except Exception as e:
        print(f"[ERROR] Consulta proveedores: {e}")

    # Los nombres de proyectos ya se asignaron antes de los filtros

    # Obtener datos de FAC. PAGO desde tabla ingresos
    try:
        ingreso_ids = set(p.get("ingreso_id") for p in pagos_ordenados if p.get("ingreso_id") is not None)
        fac_pago_map = {}
        
        if ingreso_ids:
            res_ingresos = supabase.table("ingresos").select("id, fac_pendiente").in_("id", list(ingreso_ids)).execute()
            for ing in (res_ingresos.data or []):
                ingreso_id = ing.get("id")
                fac_pendiente = ing.get("fac_pendiente")
                # Cualquier valor que no sea NULL = "SI"
                fac_pago_map[ingreso_id] = "SI" if fac_pendiente is not None else "-"
        
        for p in pagos_ordenados:
            ingreso_id = p.get("ingreso_id")
            p["fac_pago"] = fac_pago_map.get(ingreso_id, "-")
            
    except Exception as e:
        print(f"[ERROR] Consulta FAC. PAGO: {e}")

    # Aplicar filtro de estado después de tener todos los datos
    if filtros and filtros.get("estado"):
        estado = filtros["estado"]
        def get_estado_pago(p):
            if p["fecha_pago"]:
                return "pagado"
            elif p["total_abonado"] > 0 and p["saldo_pendiente"] > 0:
                return "abono"
            else:
                return "pendiente"
        
        pagos_ordenados = [p for p in pagos_ordenados if get_estado_pago(p) == estado]

    return pagos_ordenados

@login_required
@bp_informe_op.route("/informe_op", methods=["GET"])
@require_modulo('pagos')
def informe_op():
    """
    Ruta principal del informe de órdenes de pago
    Migrada desde pagos.py con optimizaciones
    """
    # Control de acceso
    modulos_usuario = [m.strip().lower() for m in get_modulos_usuario()]
    if 'pagos' not in modulos_usuario:
        flash('No tienes permiso para acceder a esta sección.', 'danger')
        return render_template('sin_permisos.html')

    # Recoger filtros de la URL
    filtros = {}
    proveedor = request.args.get("proveedor", "").strip()
    proyecto = request.args.get("proyecto", "").strip()
    estado = request.args.get("estado", "").strip()
    fecha_desde = request.args.get("fecha_desde", "").strip()
    fecha_hasta = request.args.get("fecha_hasta", "").strip()

    if proveedor:
        filtros["proveedor"] = proveedor
    if proyecto:
        filtros["proyecto"] = proyecto
    if estado:
        filtros["estado"] = estado
    if fecha_desde:
        filtros["fecha_desde"] = fecha_desde
    if fecha_hasta:
        filtros["fecha_hasta"] = fecha_hasta

    # Obtener datos usando la función optimizada
    pagos_completos = get_informe_pagos(filtros)

    # Parámetros de paginación
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 500, type=int)  # 500 registros por página por defecto
    
    # Aplicar paginación solo para la vista
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    pagos = pagos_completos[start_idx:end_idx]
    
    # Calcular totales usando TODOS los registros (no solo los paginados)
    total_registros = len(pagos_completos)
    # Corregir: solo contar saldo pendiente de registros SIN fecha de pago
    total_pendiente = sum(
        p.get("saldo_pendiente", 0) for p in pagos_completos 
        if not p.get("fecha_pago") and isinstance(p.get("saldo_pendiente"), (int, float))
    )
    total_pagados = len([p for p in pagos_completos if p.get("fecha_pago")])
    total_pendientes = len([p for p in pagos_completos if not p.get("fecha_pago")])
    
    # Información de paginación
    total_pages = (total_registros + per_page - 1) // per_page
    has_prev = page > 1
    has_next = page < total_pages
    
    print(f"[INFO] Página {page}/{total_pages} - Mostrando {len(pagos)} de {total_registros} registros")
    print(f"[INFO] Resumen: {total_pagados} pagados, {total_pendientes} pendientes")

    # Datos adicionales para filtros dinámicos
    proveedores_unicos = sorted(set(p["proveedor_nombre"] for p in pagos_completos))
    proyectos_unicos = sorted(set(p["proyecto"] for p in pagos_completos))
    
    # Calcular saldos pendientes por proyecto
    saldos_por_proyecto = {}
    for p in pagos_completos:
        if not p.get("fecha_pago"):  # Solo incluir registros pendientes de pago
            proyecto = p.get("proyecto", "Sin Proyecto")
            saldo = p.get("saldo_pendiente", 0)
            if isinstance(saldo, (int, float)) and saldo > 0:
                if proyecto not in saldos_por_proyecto:
                    saldos_por_proyecto[proyecto] = 0
                saldos_por_proyecto[proyecto] += saldo
    
    # Ordenar por monto descendente - MOSTRAR TODOS los proyectos con saldo pendiente
    saldos_por_proyecto_top = sorted(
        saldos_por_proyecto.items(), 
        key=lambda x: x[1], 
        reverse=True
    )  # Removido [:10] para mostrar todos
    
    print(f"[INFO] Proyectos únicos encontrados: {proyectos_unicos[:5]}...")  # Mostrar primeros 5

    # Calcular fecha máxima para input de fecha (hoy + 7 días)
    fecha_maxima = (date.today() + timedelta(days=7)).isoformat()

    # Permisos de edición
    puede_editar = 'pagos' in modulos_usuario

    # Registrar actividad
    registrar_log_actividad("Ver informe de órdenes de pago", f"Filtros: {filtros}, Página: {page}")

    return render_template(
        "informe_op.html",
        pagos=pagos,
        filtros_activos=filtros,
        proveedores_unicos=proveedores_unicos,
        proyectos_unicos=proyectos_unicos,
        saldos_por_proyecto=saldos_por_proyecto_top,
        fecha_maxima=fecha_maxima,
        puede_editar=puede_editar,
        total_pendiente=total_pendiente,
        total_registros=total_registros,
        total_pagados=total_pagados,
        total_pendientes=total_pendientes,
        page=page,
        per_page=per_page,
        total_pages=total_pages,
        has_prev=has_prev,
        has_next=has_next,
        date=date
    )

@login_required
@bp_informe_op.route("/informe_op/update_pagos", methods=["POST"])
@require_modulo('pagos')
def update_pagos():
    """
    Actualización masiva de fechas de pago
    CORREGIDO: Solo procesa órdenes enviadas en el formulario para evitar afectar registros de otras páginas
    """
    supabase = current_app.config["SUPABASE"]
    nums = request.form.getlist("orden_numero[]")
    fechas = request.form.getlist("fecha_pago[]")
    
    # Protección contra envío vacío
    if not nums or len(nums) == 0:
        flash("No se enviaron datos para actualizar.", "warning")
        return redirect(url_for("informe_op.informe_op"))
    
    # VALIDACIÓN CRÍTICA: Verificar que nums y fechas tengan la misma longitud
    if len(nums) != len(fechas):
        flash("Error: No coinciden las órdenes con las fechas enviadas.", "danger")
        return redirect(url_for("informe_op.informe_op"))
    
    any_error = False
    upserts = []
    deletes = []
    
    # Convertir números de orden a enteros y validar
    ordenes_validas = []
    for num in nums:
        try:
            orden_numero = int(num)
            ordenes_validas.append(orden_numero)
        except (ValueError, TypeError):
            flash(f"Número de orden inválido: {num}", "danger")
            any_error = True
            continue

    if not ordenes_validas:
        flash("No se encontraron órdenes válidas para procesar.", "warning")
        return redirect(url_for("informe_op.informe_op"))

    # Consultar fechas actuales SOLO para las órdenes del formulario
    fechas_actuales = {}
    try:
        res_fechas = supabase.table("fechas_de_pagos_op").select("orden_numero, fecha_pago").in_("orden_numero", ordenes_validas).execute()
        fechas_actuales = {row["orden_numero"]: row["fecha_pago"] for row in (res_fechas.data or [])}
    except Exception as e:
        print(f"[ERROR] Consulta fechas actuales: {e}")
        fechas_actuales = {}

    # Consultar abonos SOLO para las órdenes del formulario
    abonos_por_orden = {}
    try:
        res_abonos = supabase.table("abonos_op").select("orden_numero, monto_abono").in_("orden_numero", ordenes_validas).execute()
        
        for abono in (res_abonos.data or []):
            orden_num = abono.get("orden_numero")
            monto = int(round(float(abono.get("monto_abono") or 0)))
            abonos_por_orden[orden_num] = abonos_por_orden.get(orden_num, 0) + monto
            
    except Exception as e:
        print(f"[ERROR] Consulta abonos: {e}")
        abonos_por_orden = {}

    # Procesar cada orden EN EL ORDEN EXACTO del formulario
    for i in range(len(ordenes_validas)):
        orden_numero = ordenes_validas[i]
        fpago = fechas[i].strip() if i < len(fechas) else ""
        
        fecha_actual = fechas_actuales.get(orden_numero)
        suma_abonos = abonos_por_orden.get(orden_numero, 0)
        
        if fpago:
            # PAGO DIRECTO: Asignar fecha
            try:
                d = datetime.strptime(fpago, "%Y-%m-%d").date()
            except ValueError:
                flash(f"Fecha inválida para OP {orden_numero}", "danger")
                any_error = True
                continue
                
            if d > date.today() + timedelta(days=7):
                flash(f"Fecha de pago muy futura para OP {orden_numero}", "danger")
                any_error = True
                continue
            
            # Solo actualizar si la fecha es diferente
            if fecha_actual != fpago:
                upserts.append({"orden_numero": orden_numero, "fecha_pago": fpago})
                print(f"[INFO] Programando actualizar OP {orden_numero}: {fpago}")
        else:
            # Eliminar fecha de pago SOLO si había una fecha previa
            if fecha_actual:
                # IMPORTANTE: Solo eliminar si NO tiene abonos que justifiquen la fecha
                # Si tiene abonos completos, mantener la fecha automática
                try:
                    # Obtener el total de la orden para comparar con abonos
                    res_total = supabase.table("orden_de_pago").select("costo_final_con_iva").eq("orden_numero", orden_numero).execute()
                    total_orden = 0
                    if res_total.data:
                        total_orden = int(round(float(res_total.data[0].get("costo_final_con_iva") or 0)))
                    
                    # Solo eliminar fecha si no está justificada por abonos completos
                    if suma_abonos < total_orden:
                        deletes.append(orden_numero)
                        print(f"[INFO] Programando eliminar fecha OP {orden_numero} (abonos: {suma_abonos}, total: {total_orden})")
                    else:
                        print(f"[INFO] Manteniendo fecha automática OP {orden_numero} (abonos completos: {suma_abonos})")
                        
                except Exception as e:
                    print(f"[ERROR] Validando abonos para OP {orden_numero}: {e}")
                    # En caso de error, eliminar la fecha de forma conservadora
                    deletes.append(orden_numero)

    # Ejecutar operaciones en batch
    if upserts:
        try:
            supabase.table("fechas_de_pagos_op").upsert(upserts).execute()
            flash(f"✅ {len(upserts)} fecha(s) de pago actualizadas correctamente.", "success")
        except Exception as e:
            print(f"[ERROR] Upsert fechas: {e}")
            flash(f"Error al guardar fechas de pago: {str(e)}", "danger")
            any_error = True

    if deletes:
        try:
            supabase.table("fechas_de_pagos_op").delete().in_("orden_numero", deletes).execute()
            flash(f"✅ {len(deletes)} fecha(s) de pago eliminadas correctamente.", "success")
        except Exception as e:
            print(f"[ERROR] Delete fechas: {e}")
            flash(f"Error al eliminar fechas de pago: {str(e)}", "danger")
            any_error = True

    if not any_error and not upserts and not deletes:
        flash("No se realizaron cambios (las fechas ya estaban actualizadas).", "info")

    # Registrar actividad
    if upserts or deletes:
        registrar_log_actividad("Actualizar fechas de pago", f"Actualizadas: {len(upserts)}, Eliminadas: {len(deletes)}")

    return redirect(url_for("informe_op.informe_op"))

# ===== GESTIÓN DE ABONOS =====

@login_required
@bp_informe_op.route('/informe_op/abonos/<int:orden_numero>', methods=['GET'])
@require_modulo('pagos')
def get_abonos_op(orden_numero):
    """Obtener historial de abonos para una orden específica"""
    supabase = current_app.config["SUPABASE"]
    try:
        res = supabase.table("abonos_op").select("id, orden_numero, monto_abono, fecha_abono, observacion, created_at").eq("orden_numero", orden_numero).order("fecha_abono", desc=False).execute()
        abonos = res.data if hasattr(res, "data") and res.data else []
        
        response = jsonify(success=True, abonos=abonos)
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        
        return response
    except Exception as e:
        print(f"[ERROR] Consulta abonos_op para OP {orden_numero}: {e}")
        return jsonify(success=True, abonos=[])

@login_required
@bp_informe_op.route('/informe_op/abonos/<int:orden_numero>', methods=['POST'])
@require_modulo('pagos')
def registrar_abono_op(orden_numero):
    """Registrar nuevo abono para una orden"""
    supabase = current_app.config["SUPABASE"]
    try:
        data = request.get_json() or {}
        monto = int(round(float(data.get("monto_abono") or 0)))
        fecha = data.get("fecha_abono")
        observacion = data.get("observacion")

        if monto <= 0:
            return jsonify(success=False, error="Monto debe ser mayor a cero"), 400
        if not fecha:
            return jsonify(success=False, error="Fecha requerida"), 400

        # Validar suma de abonos vs total de la orden
        res_abonos = supabase.table("abonos_op").select("monto_abono").eq("orden_numero", orden_numero).execute()
        suma_abonos = sum(int(round(float(a.get("monto_abono") or 0))) for a in (res_abonos.data or []))

        res_pago = supabase.table("orden_de_pago").select("costo_final_con_iva").eq("orden_numero", orden_numero).limit(1).execute()
        if not res_pago.data:
            return jsonify(success=False, error="No se encontró el total de la orden."), 400
        total_pago = int(round(float(res_pago.data[0].get("costo_final_con_iva") or 0)))

        nueva_suma = suma_abonos + monto
        if nueva_suma > total_pago:
            return jsonify(success=False, error=f"La suma de abonos ({nueva_suma}) supera el total de la orden ({total_pago})."), 400

        # Insertar abono
        abono = {
            "orden_numero": orden_numero,
            "monto_abono": monto,
            "fecha_abono": fecha,
            "observacion": observacion or None,
        }

        res = supabase.table("abonos_op").insert(abono).execute()
        if hasattr(res, "error") and res.error:
            return jsonify(success=False, error=str(res.error)), 500

        # Si completa el total, registrar fecha_pago automáticamente
        if nueva_suma == total_pago:
            supabase.table("fechas_de_pagos_op").upsert(
                {"orden_numero": orden_numero, "fecha_pago": fecha}, 
                on_conflict=["orden_numero"]
            ).execute()

        return jsonify(success=True)
    except Exception as e:
        return jsonify(success=False, error=str(e)), 500

@login_required
@bp_informe_op.route('/informe_op/abonos/<int:abono_id>', methods=['PUT'])
@require_modulo('pagos')
def editar_abono_op(abono_id):
    """Editar abono existente"""
    supabase = current_app.config["SUPABASE"]
    try:
        data = request.get_json() or {}
        monto = int(round(float(data.get("monto_abono") or 0)))
        fecha = data.get("fecha_abono")
        observacion = data.get("observacion")
        
        if monto <= 0:
            return jsonify(success=False, error="Monto debe ser mayor a cero"), 400
        
        # Obtener orden_numero del abono
        res_abono = supabase.table("abonos_op").select("orden_numero").eq("id", abono_id).limit(1).execute()
        if not res_abono.data:
            return jsonify(success=False, error="No se encontró el abono."), 400
        orden_numero = res_abono.data[0]["orden_numero"]
        
        # Obtener total_pago de la orden
        res_pago = supabase.table("orden_de_pago").select("costo_final_con_iva").eq("orden_numero", orden_numero).limit(1).execute()
        if not res_pago.data:
            return jsonify(success=False, error="No se encontró el total de la orden."), 400
        total_pago = int(round(float(res_pago.data[0].get("costo_final_con_iva") or 0)))
        
        # Consultar otros abonos (excluyendo el que se está editando)
        res_otros_abonos = supabase.table("abonos_op").select("monto_abono").eq("orden_numero", orden_numero).neq("id", abono_id).execute()
        suma_otros_abonos = sum(int(round(float(a.get("monto_abono") or 0))) for a in (res_otros_abonos.data or []))
        
        # Validar suma total
        nueva_suma = suma_otros_abonos + monto
        if nueva_suma > total_pago:
            return jsonify(success=False, error=f"La suma de abonos ({nueva_suma}) supera el total de la orden ({total_pago})."), 400
        
        # Actualizar abono
        update_data = {"monto_abono": monto}
        if fecha:
            update_data["fecha_abono"] = fecha
        if observacion is not None:
            update_data["observacion"] = observacion
        
        res = supabase.table("abonos_op").update(update_data).eq("id", abono_id).execute()
        if hasattr(res, "error") and res.error:
            return jsonify(success=False, error=str(res.error)), 500
        
        # Manejar fecha de pago automática
        if nueva_suma == total_pago:
            supabase.table("fechas_de_pagos_op").upsert(
                {"orden_numero": orden_numero, "fecha_pago": fecha or date.today().isoformat()}, 
                on_conflict=["orden_numero"]
            ).execute()
        elif nueva_suma == 0:
            supabase.table("fechas_de_pagos_op").delete().eq("orden_numero", orden_numero).execute()
        
        return jsonify(success=True)
    except Exception as e:
        return jsonify(success=False, error=str(e)), 500

@login_required
@bp_informe_op.route('/informe_op/abonos/<int:abono_id>', methods=['DELETE'])
@require_modulo('pagos')
def eliminar_abono_op(abono_id):
    """Eliminar abono existente"""
    supabase = current_app.config["SUPABASE"]
    try:
        # Obtener información del abono antes de eliminarlo
        res_abono = supabase.table("abonos_op").select("orden_numero").eq("id", abono_id).limit(1).execute()
        if not res_abono.data:
            return jsonify(success=False, error="No se encontró el abono."), 400
        orden_numero = res_abono.data[0]["orden_numero"]

        # Eliminar abono
        res = supabase.table("abonos_op").delete().eq("id", abono_id).execute()
        if hasattr(res, "error") and res.error:
            return jsonify(success=False, error=str(res.error)), 500

        # Verificar suma restante y manejar fecha de pago automática
        res_abonos_restantes = supabase.table("abonos_op").select("monto_abono").eq("orden_numero", orden_numero).execute()
        suma_restante = sum(int(round(float(a.get("monto_abono") or 0))) for a in (res_abonos_restantes.data or []))
        
        if suma_restante > 0:
            res_pago = supabase.table("orden_de_pago").select("costo_final_con_iva").eq("orden_numero", orden_numero).limit(1).execute()
            total_pago = int(round(float(res_pago.data[0].get("costo_final_con_iva") or 0))) if res_pago.data else 0
            
            if suma_restante < total_pago:
                supabase.table("fechas_de_pagos_op").delete().eq("orden_numero", orden_numero).execute()
        else:
            supabase.table("fechas_de_pagos_op").delete().eq("orden_numero", orden_numero).execute()

        return jsonify(success=True)
    except Exception as e:
        return jsonify(success=False, error=str(e)), 500

# ===== EXPORTACIÓN A EXCEL =====

@login_required
@bp_informe_op.route("/informe_op/export", methods=["GET"])
@require_modulo('pagos')
def export_informe_op():
    """
    Exportar informe completo a Excel
    Incluye filtros si se especifican en la URL
    """
    # Obtener filtros de la URL
    filtros = {}
    proveedor = request.args.get("proveedor", "").strip()
    proyecto = request.args.get("proyecto", "").strip()
    estado = request.args.get("estado", "").strip()
    fecha_desde = request.args.get("fecha_desde", "").strip()
    fecha_hasta = request.args.get("fecha_hasta", "").strip()

    if proveedor:
        filtros["proveedor"] = proveedor
    if proyecto:
        filtros["proyecto"] = proyecto
    if estado:
        filtros["estado"] = estado
    if fecha_desde:
        filtros["fecha_desde"] = fecha_desde
    if fecha_hasta:
        filtros["fecha_hasta"] = fecha_hasta

    # Obtener datos con filtros aplicados
    pagos = get_informe_pagos(filtros)

    # Crear workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Informe de Órdenes de Pago"

    # Headers
    headers = [
        "Orden N°", "Fecha", "Proveedor", "RUT", "Detalle", "Factura", 
        "FAC. PAGO", "Total", "Abonado", "Saldo Pendiente", "Proyecto", 
        "Items", "OC", "Condición", "Vencimiento", "Fecha Factura", 
        "Fecha de Pago", "Cuenta"
    ]
    ws.append(headers)

    # Formatear datos para Excel
    def format_clp_excel(value):
        """Formatear moneda para Excel"""
        try:
            if isinstance(value, (int, float)):
                return int(value)
            return 0
        except:
            return 0

    # Datos
    for p in pagos:
        row = [
            p.get("orden_numero", ""),
            p.get("fecha", ""),
            p.get("proveedor_nombre", ""),
            p.get("rut_proveedor", ""),
            p.get("detalle_compra", ""),
            p.get("factura", ""),
            p.get("fac_pago", ""),
            format_clp_excel(p.get("total_pago", 0)),
            format_clp_excel(p.get("total_abonado", 0)),
            format_clp_excel(p.get("saldo_pendiente", 0)),
            p.get("proyecto", ""),
            p.get("item", ""),
            p.get("orden_compra", ""),
            p.get("condicion_pago", ""),
            p.get("vencimiento", ""),
            p.get("fecha_factura", ""),
            p.get("fecha_pago", ""),
            p.get("cuenta", "")
        ]
        ws.append(row)

    # Ajustar ancho de columnas
    for column_cells in ws.columns:
        length = max(len(str(cell.value)) for cell in column_cells)
        ws.column_dimensions[column_cells[0].column_letter].width = min(length + 2, 50)

    # Guardar en memoria
    output = BytesIO()
    wb.save(output)
    output.seek(0)

    # Nombre del archivo con timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M")
    filename = f"informe_ordenes_pago_{timestamp}.xlsx"

    return send_file(
        output, 
        download_name=filename, 
        as_attachment=True,
        mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )
